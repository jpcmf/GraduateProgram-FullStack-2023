# Design de UI

## Aula 01 - Joe Natoli

### Prototyping

#### What exactly is a prototype?

A prototype is a **simulation** of a finished product.
- represents how **interaction** between the user + the interface would work.
- serves as an imitation of how the real-world **processes** underneath the UI would work.
- can represent a **single interaction** or an **entire app experience** from login to logout.

#### Why do we prototype? 

To **test**.

USABILITY
- will this work for users in a way they can easily understand and act upon?
- does it surface action and information where, when and how they need it?

FEASIBILITY
- is it possible to actually build this?
- do we have the time, budget, resources, knowledge and access to technology?

VIABILITY
- how will we support + improve this?

#### Prototyping ensures we get it right.

We test ideas with real users, so we can see how they expect + want to use the product. prototypes tell us:
- if what they **expect** is what they **get**
- what’s easy to use + understand
- where, how + why they get stuck or tripped up or confused or frustrated

#### Testing reveals the parts that need improvement.

we’re finding + resolving usability issues well before launch.

this allows us to adjust the design, test again + keep doing so until we get it right.

#### Create, test, learn, revise, repeat.

**create** the solution, exploring content, interaction, UI + UX.

**test** the prototype with users, to **learn** how well it meets needs + expectations.

**revise** areas that need to be refined, defined, improved or clarified.

**repeat** ;-)

#### Start small.

you start with only a few **key screens** or sequences.

as you iterate + test, the prototype grows in **breadth** and **depth**; more screens, content + interaction.

along the way you make **changes to smaller details**, in real-time + across iteration cycles of days or weeks.

#### How much is enough?

usually it’s **20% of the functionality** that will be used 80% of the time.

this is the stuff you have to get right in order for people to **recognize** that the product meets their needs.

it’s the content + interactions + visual presentation that ensure they’ll be **able + willing** to use it.

#### Sequences, not screens.

you never prototype a single screen.

you prototype a sequence, a **journey**, from start to finish.

e.g. *“Joe logs in to the banking app, checks his balance and transfers money from checking to savings.”*

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/b4539e0a-c22e-48c9-aba5-f34fa978f6b0)

#### Wireframes, prototypes + mockups (oh my!)

- unlike sketches, wireframes or mockups, a prototype is an **interactive simulation**.
- sketches, wireframes and mockups are essentially **static** components.
- if you can’t tap, click or swipe through it and have it respond to those actions + gestures, **it’s not a prototype**.

#### Protoyping software

Adobe XD, UXPin, Figma, Sketch + others will export static screens to a **clickable, interactive prototype**.

you create low-fidelity wireframes + export them as a prototype.

there are many — so how do you choose the best tool to use?

#### Choose a tool that...

is **easy** for you to learn and use.

is **flexible**, meaning it can be used to create prototypes for web, desktop + mobile apps.

has a **large library** of stencils, templates + widgets, either built in or available from third parties.

makes it easy to **share** the prototype with others for testing + review.

can **capture** feedback during use.

allows **changes on the fly**, while getting feedback in a session.

allows **collaboration**, e.g. multiple people working on the prototype at the same time.

### The problems prototypes solve

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/099d9a47-d1f2-4977-ba9f-5bbeb5b8f9e1)

#### There are two choices at the outset of a project.

1. **start building with production-ready code**, launch it and see how people react.
2. **build + test low-fidelity prototypes early + often**, to figure out what’s actually worth building.

#### Guess which approach is usually chosen?

prototyping makes a lot more sense + creates a lot less waste in terms of unnecessary work / rework.

however, far too many organizations take the first approach + **dive right into coding**.

the result?

teams are grossly **overworked + stressed out**.

they’re spending 50% or more of their time **reworking things** that either aren’t functioning properly or aren’t delivering the intended user or business results.

backlogs are growing exponentially + management isn’t getting the **results** they hoped for (usually money made or money saved).

**new requirements + requests** keep showing up even after code is committed.

emergency meetings are called; changes and revisions and rework are **endless**.

people are working themselves to death long past dark seven days a week, trying to reach a finish line that **keeps moving** every time they get close to it.

and if all of that weren’t enough, **users are frustrated** — and often angry.

they’re taking their business elsewhere.

to a competitor who isn’t using them as guinea pigs to test a bunch of new features they didn’t ask for.

there’s only one antidote.

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/c5c8ec7c-09ee-4292-9d93-5b31d313369e)

#### Starting the minute a project becomes real.
- allows everyone to quickly get a handle on what **features + functionality** could or should be.
- how it will actually **work** when someone uses it.
- prototypes communicate the experience in UX; allows us to test its **value** and **usefulness**.

1. enables better UX + design decisions.
- critical interactive design choices can be finalized in prototyping.
- hi-fi prototypes deliver instant feedback in testing, allowing informed, educated decisions.
- instead of a guess based on “best practice” design / UX principles.

2. keeps focus on UX + context of use.
- you’re using all your senses when working with a prototype.
- so when something doesn’t work as expected, it’s real to you.
- you experience the same visceral, emotional reaction a user does.
- users normally test prototypes in a “real life” environment + context.
- external, contextual factors that affect ease of use, like distractions or noise or device limitations — are all present.
- experiences are truer to life, so your test results are more useful.

3. non-sequential + doesn’t hold up any other work.
 - developers are still coding, database folks + software architects are still working out structure + architecture.
 - “we don’t have time for prototyping, everyone else will be waiting for it to be done, or for test results.”
 - if it slows you down, you’re doing it wrong.

### Why do we need prototyping?

because designing a relevant, personalized, optimized experience for **seven billion humans** is impossible.

#### products often fail.

prototyping can both **prevent** and **predict** that failure.

without prototyping, everyone is guessing at what will be useful, usable or valuable to people.

they’re following a model of software design that focuses on **implementation** — instead of expectation and understanding.

#### this is a failure to design for user mental models.

we rely on mental models, abstract representations of how things work, to use just about everything.

we use them to try + understand complex behaviors and processes.

they’re how we believe something **might** work or **should** work, based on our experiences with other things.

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/4548eb71-6cfe-408f-9cc5-43f783ae88c1)

and here’s what happens as a result.

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/3c83ace7-5d12-4d74-865e-e90c09e1ea02)

**rapid prototyping** narrows the gap.

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/9c44a232-70c7-4768-8835-3bf382fa2a96)

#### rapid prototyping narrows the gap.
- we can quickly, cheaply + accurately learn what those models are.
- we understand how best to serve them via functionality, interaction + UI.
- how? by quickly iterating on design, testing, improving design, testing again.
- real-time learning, low design time/effort and minimal delay between cycles.


1. shared understanding across team, stakeholders + clients.
   - **limitations** + **possibilities** are evident in context of use; the evidence is in the experience itself.
   - people see for themselves how intuitive, easy or difficult it is to understand + use.
   - or if additional guidance or instruction or evidence is missing or necessary.
   - conversation + documentation are wide open to misinterpretation + subjectivity.
   - shared experience is **shared understanding**.
   - prototypes keep everyone’s focus where it belongs: on the **experience**.
   - (instead of on the visual elements they see.)
   - prototypes help to get approval or buy-in from a client, stakeholder, product owner or fellow team member on an idea.
   - prototyping gets skeptics to **try something** before making up their minds it’s the wrong approach or won’t work.

>  never go to a client meeting without a prototype. its ability to communicate and persuade is often the difference between a YES or a NO. –– DAVID + TOM KELLEY, IDEO

2. prototypes avoid critical mobile UX mistakes.
   - prototyping is **mandatory** for mobile.
   - mobile use spans a massive number of use cases, scenarios, technological variables, limitations + constraints.
   - mobile use environments change frequently and are almost impossible to predict.
   - input methods are radically different from desktop, from limited keyboard functionality to complex gesturing.
   - screens are smaller + more restrictive, both in size and ergonomically.
   - people literally use their hands + fingers differently in different situations.
   - mobile apps cost $15 - $500K to develop.
   - so mistakes + rework to correct those mistakes is really, really expensive.
   - catching + correcting these things in prototyping is a lot cheaper, easier + less stressful for everyone involved.

3. the earlier you find + fix problems, the easier it is.
   - if we’ve made a wrong turn, I want to know now, at the beginning of the journey.
   - when it costs us nothing to turn the car around and try again.
   - if users will hate a feature, too expensive or time-consuming to build, I want to know before we’ve spent time + money.
   - if we learn this 6 weeks from now...
     - **we have to scrap what we have** and...
     - r**e-work the entire thing**, which, in complex systems, usually also means...
     - **decoupling + reimagining** any number of third-party module or system dependencies.
 
4. prototyping allows you to judge design feasibility.
   - requirements and specifications are words on paper; a prototype is a **dose of reality**.
   - teams can quickly experiment, explore + test to see if proposed interaction or data/content will give users what they need.
   - prototyping allows the team to get a handle on estimated effort and duration.

5. prototyping greatly reduces surprise requests.
   - managers + stakeholders can see for themselves exactly what is + **is not** going to be built.
   - so they’re not left to wonder whether that list of things that exists only in their heads is going to make it into the build.

6. closes the gap between design + development.
   - a Rosenfeld Media study found that when developers were given a prototype instead of flat designs and specifications to quote against and build to...
   - ...development requests for clarification on design + UX **dropped by 80%**.
   - giving both the same goal to work toward.
   - designers and developers may speak multiple, different languages...
   - but a prototype speaks **all of them**.
   - quick iteration allows for collaboration; instead of “handing off,”devs are involved in the iteration, giving feedback on proposed features, interaction + functionality.

7. answers the 3 critical questions of product design.
   - **one: is this worth doing?**
     - every minute spent researching, designing + developing a feature is an investment.
     - are we certain that every requirement on our list delivers a return on that investment?
   - **two: does everyone agree on + understand what we’re creating?**
     - does every member of the team share the same understanding of what’s being built + why it matters?
    
   - **three: what value does it deliver?**
     - does this improvement, feature, or function facilitate a desired outcome for both customers and the organization?
     - do we know it will deliver that value?
     - or are we guessing?
     - tangible, evidence-based answers to these questions from prototyping + testing ensure we design + build features that matter.
     - standing them up onscreen in a way that users expect, can understand + are able to easily use.
     - we know what we’re doing.
     - we know what we’re not doing.
     - and in both cases...
     - we know WHY those things are or are not important.
    
### How close to “real” should a prototype be?

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/974333ac-a367-459c-8730-4a98aea357e0)

it depends.

we use different levels of fidelity depending on what we need to **know + test + learn**.

differences in fidelity are most obvious in the areas of:
- visual UI design
- content
- interactivity

product teams choose the right fidelity based on three things:
- **goals** of prototyping
- **completeness** of design
- available **resources**

#### there are three levels of fidelity to consider.

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/d54a802b-3f40-4a11-bc39-292ad3386a9c)

#### low-fi prototypes
 - **hand sketched** (or whiteboard), paper-or computer-based.
 - **limited user interaction** (or none if hand-drawn)
 - **quickest to create**; no special tools or experience required; can be done alone with a sketchbook or in a group with a whiteboard.
 - promotes innovation + improvement through **rapid iterations**.
 - ideal for **multiple**, **iterative** design explorations.
 - **quick way to get feedback from users** via rough approaches + concepts.
 - gives **comfort + psychological** safety to suggest changes.
 - **invites collaboration, participation + feedback** because nothing feels “decided.”
 - **ideal during brainstorming + conceptualization** work with stakeholders, developers, etc. to generate ideas.

#### mid-fi prototypes
 - **happy medium** between high + low fidelity.
 - **more content + UI detail is progressively added** based on learnings from lo-fi iteration + testing
 - **minimal or “faked" interactivity**, e.g. wireframes exported to clickable HTML format.
 - **true functional fidelity is minimal**; interactivity can be simulated by linking pages/ screens.
 - **focus is on demonstrating the behavior** of the app, site or system, determining whether user needs are met + if the UX is appropriate + positive.

#### hi-fi prototypes
 - **realistic (click, tap, swipe, etc.) user interactions** that work on multiple devices.
 - **exact representation of the UI + its interactivity**; true simulation of form + function; like using the real thing.
 - **ideal for collecting measurable data** on user behavior.

### Low-fidelity prototyping

#### goal: check + test usability + functionality

we’re not concerned with how the UI should look; our focus is on:
 - how things **work**.
 - how **well** they work.
 - whether or not those interactions will be **understood + can be used** by people.

working in low-fidelity early on in a project is always wise.

#### rules for low-fidelity prototyping

1. **limited colors (blue for buttons + hyperlinks)**; everything else is filled with shades of grey to indicate visual hierarchy.
2. **no images or graphical data displays**; introduce either and reviewers will fixate on them instead of casting a critical eye to layout, content structure, controls, interactivity + workflow.
3. **no fonts other than Arial**; as with colors and images, fonts only invite analysis and speculation.
4. **real labels on all interactive components**; give real examples in order to get good feedback, even if nothing’s approved: navigation menu items, data tables, buttons, form fields, etc.
5. **real text content, to whatever degree possible**; content provides context to design around; a rough draft or guess at your content is much better than “lorem ipsum.”
6. **keep interactions simple**; anything requiring significant, real coding for demonstration purposes is something you need to drop, re-think, or table for a hi-fi prototype.
7. **annotate to begin suggesting and documenting functionality and requirements**; it’s your responsibility to communicate the rationale of all interaction decisions. *annotated prototypes reduce misinterpretation — you create contextual rather than “paper trail” documentation.*

## Aula 02 - Joe Natoli

## Aula 03 - Luana Mueller
