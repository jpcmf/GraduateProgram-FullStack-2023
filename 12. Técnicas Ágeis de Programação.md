# Técnicas Ágeis de Programação

## Aula 01 - Daniel Wildt / Guilherme Lacerda

> A questão não é **SE** a qualidade técnica é importante, mas **COMO** a qualidade técnica será alcançada –– Jim Highsmith *Agile Project Management: creating innovative products, Addison-Wesley Professional (2004)*

### Parte 1

#### Manifesto Ágil

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/40c230ca-8d17-4193-b03f-e9c0f42e5556)

#### Princípios e o dia a dia da equipe

- Satisfazer o cliente, entregando o software em tempo hábil e continuamente.
- Aceitar as mudanças de requisitos, em qualquer fase do projeto.
- Entregar software na menor escala de tempo possível.
- Equipe de desenvolvimento e cliente são do mesmo time.
- Construir projetos com indivíduos motivados e comprometidos com o resultado.
- Usar a comunicação efetiva.
- Ter o software em funcionamento é a principal medida de progresso.
- Atenção contínua à excelência técnica.
- As melhores arquiteturas, requisitos e projetos provêm de equipes organizadas.
- Refletir sobre como se tornar mais eficaz, ajustando e adaptando o comportamento da equipe.

`Simplicidade – a arte de maximizar a quantidade de trabalho não realizado – é essencial.`

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/cb104f8c-ab7a-45a8-8ad3-66ae4b552ad3)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/9c3c1c1e-ad0f-494b-b354-e6afff3b1802)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/2f43b0d6-b7fb-47e2-8fcd-aba030c42025)

### Parte 2 

#### 3C

- **Cartão:** informação limitada, opera como um lembrete.
- **Conversação:** quem nos ajuda a amplificar o conhecimento e desenvolver exemplos sobre o que estamos.
- **Confirmação:** conforme conversamos com clientes conseguimos comprovar os atendimentos, através de validação com o mundo real.

**A importância das entregas frequentes!**

#### Spikes

- Aprender antes, para depois poder descobrir e habilitar a entrega.
- Tempo de investigação.
- Preparação para o fazer.
- Remoção de risco técnico.
- Modo descoberta e modo entrega.

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/1246813d-da41-4db1-9e16-2fec379a86a2)

#### Ritmo Sustentável

- Como funciona a sua vida?
- Qual tempo existe para você?
- Quando você aprende?
- Quando você não faz nada?
- Ritmo sustentável trata de tempo de presença, tempo de foco.
- Horas extras? Eventualmente vai acontecer. Você vai assumir por entender suas responsabilidades.

#### Formação de times

- Multidisciplina.
- Carreira T, Pi, W?
- Como a equipe aprende?
- O que você faz quando não se sabe o que fazer?
- O que você faz quando não se tem o que fazer?

**Lean Enterprise**

- Empresa
  - Um sistema complexo e adaptativo composto de pessoas que compartilham um propósito comum.
 
![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/ff570e5c-b1a2-4621-8063-5aac7c96a847)

### Parte 3

> "Todas as religiões, artes e ciências são ramos da mesma árvore." –– *Albert Einstein*

#### O que é Metáfora?

**O Uso**
- A metáfora não é só uma figura de linguagem.
- Ela está presente de forma intensa porém imperceptível em tudo que os humanos fazem.
- Nós falamos uma metáfora a cada 10 a 25 palavras, ou seja, cerca de seis metáforas por minuto.
- A metáfora é uma maneira de pensar muito antes de ser um estilo com palavras.

#### Metáforas no desenvolvimento de software

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/0da36e70-1525-4f72-8253-1ba41619f324)

**Por que elas são importantes?**
- As metáforas têm um grande valor.
- Ampliam o poder de comunicação.
- Compreensão compartilhada e colaborativa.
- Uso de alto e baixo nível, diferentes níveis de abstração.

> "O talento vence jogos, mas só o trabalho em equipe vence campeonatos." –– *Michael Jordan*

#### O trabalho da pessoa desenvolvedora

- Principais Atividades
  - Design/Programação/Testes/Manutenção/Evolução.
  - Gestão de configuração e do trabalho.
  - Colaborar com outros profissionais.
 
- Desafios
  - Dominar tecnologia(s).
  - Manter-se atualizada(o).
  - Ter a visão do todo.
  - Ser especialista/generalista.
  - Interagir com clientes/usuários.
  - Preocupar-se constantemente com a qualidade.
  - Se adaptar!

#### Padrões/Convenções

- Toda a linguagem tem
  - E por que não usamos?
  - Quais são os benefícios?
  - Prática do XP.
 
- Componentes
  - Nomenclatura.
  - Estrutura do código.
  - Terminologia.
  - Formatação.
  - Boas Práticas.
  - Exemplos.
 
#### Pair Programming e Mob Programming

- Pair Programming
  - Mecânica.
  - Ferramentas.
 
- Mob Programming
  - Mecânica
 
![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/2f5bc6e1-b856-400c-a6c9-0bf12fb4be51)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/7159a730-909d-4b3d-a1a6-6f4cde100398)

## Parte 3

#### Bad Smells

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/59068f6e-c5d5-4f70-af2e-ea1f48efa79b)

#### Engenharia de Software

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/be776814-7de1-421a-95d0-27b33b631986)

#### Complexidade

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/e6c89f13-20fd-4429-bfa9-cf83c8ef1a14)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/6c584247-a601-4bcf-b393-7a62faa420b5)

#### Manutenção

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/c7d22d20-23b4-449f-a0cd-7bd4d0f9f6c4)

**Visões**

Desenvolvimento **+** Manutenção = **Evolução!**

**Problemas na Documentação**

**Taxonomia**
- Construída a partir de mais de 800 documentos, incluindo PRs do Github e threads do StackOverflow.
- Problemas: Incompletude, falta de atualização, pouca usabilidade, pouca legibilidade.
**Principais dores**
- Documentações que ferem os critérios de completude, atualidade e legibilidade.
- Falta de Corretude: documentações com informações erradas.
 
**Documentação Técnica**

**Estrutura**
- Conteúdo, tamanho, audiência, formato (tutorial, vídeos).
- Contar uma história.
- Use e abuse de exemplos de código.

**Elementos e exemplos**
- Diagramas (Maps, UML, entre outros).
- Arquitetura: C4 Model, Architecture Haiku, Architecture Decision Records (ADR).
- Mockups, protótipos navegáveis.
- Engenharia Reversa: Artefatos, Visualização de Software.
- Código: Programação Literata, comentários e documentações no código.
- Testes: documentação automatizada.
- Guias: Deployment, contribuição, instalação/uso, primeiros passos.

## Aula 02 - Daniel Wildt / Guilherme Lacerda

### Parte 1

#### Testes

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/6e7095b8-9088-46b8-ba5a-7c15ea085a9a)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/6c32deb8-7d02-45ab-96f9-69450ffb8bae)

#### Testes ou Design?
- Nossos testes automatizados representam nosso design.
- Que estruturas precisamos para resolver o problema?
- Quais limites e restrições que o problema de negócio nos impõe?

#### A importância das perguntas
- Como sabemos que terminamos a nossa tarefa?
- Como sabemos que estamos preparados para iniciar?

**A importância dos critérios de aceite!**
- Ajudam a cadenciar o trabalho.
- Ajudam a fazer somente o necessário (_just enough_).
- Cenários demonstram exemplos que definem os limites do nosso trabalho.

#### Automação e Integração Contínua
- Você mantém seu código na sua máquina por quanto tempo?
- Se seu código entrar na base de produção, vai quebrar alguma coisa?
- Como o seu código chega até quem vai usar e gerar valor a partir da sua entrega?
- Como funcionam os builds da sua equipe?

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/3d622e04-9391-4037-9c36-bd8b10367128)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/1c4d057a-7b2b-463f-8d88-5e9d1fc84bc8)

### Parte 2

#### Escrita de Histórias
- Podemos ir na evolução do 5W2H, mas procurando entender
  - Quem queremos impactar? Que atividades queremos impactar?
    - Personas ou Jobs?
   
  - Que valor vamos gerar?
    - Benefício e impacto. Precisa ser feito mesmo? E se não for feito?
   
  - O que precisa ser feito?
    - Qual o progresso?
   
  - Como sabemos se fizemos o que precisa ser feito?
    - Critérios de aceite. Como vai ser testado?
    - O tamanho da história está adequado?
   
![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/a06adda7-42d8-4edd-b2a9-1fec89134763)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/5c9de9b7-fb04-498a-abf3-3cf0883266df)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/ec71eb6e-dc34-4898-9a39-914b890f730d)

[https://www.youtube.com/watch?v=ReM1uqmVfP0&ab_channel=Strategyzer](https://www.youtube.com/watch?v=ReM1uqmVfP0&ab_channel=Strategyzer)

#### Quem atendemos?

Qual o objetivo de uma persona? Qual o detalhamento?

Abertura para conversas.

#### E se começarmos a entender sobre elas?

Dores, ganhos e tarefas. Que resultado está sendo buscado? Cuidado. Não é a simples realização da tarefa, mas o benefício que ela gera.

#### Histórias de Usuário?

Situações:
- Pagar um boleto
- Comer enquanto dirige
- Pendurar um quadro

[https://www.wildtech.com.br/historias-de-usuario](https://www.wildtech.com.br/historias-de-usuario)

#### Jobs to be done

Situações:
- Pagar um boleto
- Comer enquanto dirige
- Pendurar um quadro

[https://jtbd.info/replacing-the-user-story-with-the-job-story-af7cdee10c27](https://jtbd.info/replacing-the-user-story-with-the-job-story-af7cdee10c27)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/23345274-13b0-4b4d-a895-962043f33e3b)

#### Cenários e Testes
- Os testes ajudam a validar o nosso progresso.
- Cenários devem representar **exemplos** reais de clientes.
- Use perguntas para guiar a construção:
  - **Dado que?** Em que estado está o sistema, para iniciarmos o trabalho? Qual a **pré-condição**?
  - **Quando?** Qual **ação** está acontecendo no sistema?
  - **Então?** Como ficou o sistema depois da ação realizada? O que é esperado? Qual foi a **reação** do sistema?

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/9aeb22f6-09db-4f64-836e-85bdbaa33786)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/0a2f53ee-b8ac-46b1-9b9c-77b88b26a75d)

#### O Ritmo do TDD
- Nosso **progresso de trabalho** acontece de cenário de teste em cenário de teste a ser construído.
- Quando um **teste não passa** você tem oportunidade de modificar **comportamento**.
- Quando seus **testes passam**, você tem oportunidade de modificar a **estrutura**.

**Importância da prática de testes: Coding DOJO!**

[https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html](https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html)

#### Validação no mundo real
- Sua equipe diferencia deploy de um release?
- Como validar funcionalidades sem impactar todos clientes?
  - Estratégias de liberação: clientes beta, tipos de clientes?
  - Feature Toggles.
- Só para lembrar... desde quando podemos validar?
  - Importância dos protótipos!
 
### Parte 3

> "Grande parte do dinheiro gasto com desenvolvimento de software é usado para entender códigos existentes." –– Kent Beck

#### Dívida Técnica
- Criado por **Ward Cunningham**
- Originária do **setor financeiro**

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/5e545085-a12a-4d44-9520-6f0082ac89fd)

[https://martinfowler.com/bliki/TechnicalDebt.html](https://martinfowler.com/bliki/TechnicalDebt.html)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/7e1e9f19-f2f5-41ce-b9ae-cc22d49c5192)

[https://martinfowler.com/bliki/DesignStaminaHypothesis.html](https://martinfowler.com/bliki/DesignStaminaHypothesis.html)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/2f6b90f0-0760-4bbc-b76c-191f79127be0)

[https://tusharma.medium.com/four-strategies-for-managing-technical-debt-9d3d37a0c862](https://tusharma.medium.com/four-strategies-for-managing-technical-debt-9d3d37a0c862)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/9a11cb68-04a9-4843-9209-4e2ead8febf4)

[https://martinfowler.com/bliki/TechnicalDebtQuadrant.html](https://martinfowler.com/bliki/TechnicalDebtQuadrant.html)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/e739b35b-6f17-406b-9680-668897d9d3bd)

#### Tipos de Dívida Técnica
- Design Debt
- Architecture Debt
- Documentation Debt
- Test Debt
- Code Debt
- Defect Debt
- Requirements Debt
- Infrastructure Debt
- Test Automation Debt
- Process Debt
- Build Debt
- Service Debt
- Usability Debt
- Versioning Debt

#### Atividades Relacionadas

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/6b391a8d-e487-4839-9fca-059687b7fff8)

#### Priorizando

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/a0c23155-adbc-4cf9-b297-ffdfe2cc8a85)

[https://amzn.to/3Ld3rzp](https://amzn.to/3Ld3rzp)

> "Profissionais passam 40% da sua jornada semanal lidando com problemas de manutenção, como depuração e refatoração, além de correção de ‘código mal escrito’. Segundo a pesquisa, o impacto disso equivale a quase US$ 85 bilhões em custo de oportunidade perdido anualmente em todo o mundo, de acordo com os cálculos sobre o salário médio do desenvolvedor por país." –– Stripe, The Developer Coefficient (2018)

#### Refactoring: um processo complexo

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/8a7e9134-6708-4405-b45b-f4d07e33cad5)

#### Processo de Decisão

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/11c05171-3953-4267-87c9-548a8d641f37)

#### Motivadores

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/9bba9643-390d-4c86-a34f-843761d4221b)

#### E o código legado?

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/de9df141-e928-4c0e-bde5-3d6f1b9a2d02)

### Parte 4

#### Para refletir

Quanto tempo você leva para "aprender" sobre o repositório de código que você trabalha?

E se você trocar de empresa, em quanto tempo você consegue efetivamente "colocar a mão na massa"?

#### O que é análise de código?

#### Por que analisar código é importante?
- **Ampliar** nossa **capacidade cognitiva** de programação
- **Conhecer** outros **paradigmas, padrões e linguagens** (e **problemas** também!)
- **Ampliar** nossas **habilidades**

#### Quais habilidades precisamos desenvolver?
- Conhecer **heurísticas de análise para as estruturas**
  - Módulos/Pacotes, Classes, Métodos
 
- Compreender aspectos de **qualidade de software**
  - Atributos externos e internos
 
- Aplicar **métricas** de análise, estratégias de **visualização e ferramentas de apoio**
  - Compreensão de software, mineração de repositórios
 
- **Estratégias**
  - Análise Estática, Análise Dinâmica, Análise Temporal, Análise Comportamental
 
#### Tipos
- Estática
- Dinâmica
- Histórica
- Comportamental

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/b3f9c8c2-723f-430b-b488-713cb5fcaac4)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/53eed58a-05c2-47a3-a095-c3a343c40a4f)

#### Pilares da Análise
- Coesão
- Acoplamento
- Tamanho
- Complexidade

#### Essência da Análise: Legibilidade e Compreensão
- Estruturas **pequenas**
- Nomes **significativos**
- **Formatação** e uso de padrões (code conventions)
- **Organização** das estruturas e algoritmos
- Aplicação dos **princípios do paradigma**
- **Testes** automatizados

#### Um Kata para Análise de Código
- Defina um **objetivo para análise**
- Rode alguma(s) **ferramenta(s) de análise** para encontrar o ponto que **você deseja**
  - Níveis de granularidade
  - Uso de testes automatizados
  - Padrões adotados
 
- Você pode começar de **"dentro para fora"**
  - Análise as funções/métodos, suas estruturas e design
  - Considere os pilares
  - Suba a granularidade, quando necessário
 
#### Qual o melhor momento para fazer as análises?
- **Sempre!!!**
  - E de forma antecipada e quando possível
 
- **Individualmente**, antes de fazer commits
  - Inspeção na fonte (Poka-yoke, do Lean)
  - Apoiado por ferramentas (Jidôka, do Lean)
 
- **Em par**, para discutir situações específicas
- Em sessões de **Code Review**

#### Um episódio de análise de código

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/1d1b6e59-43f4-413e-af64-044dffbe1041)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/3ce3fd05-07ae-4114-bbf8-631f68f5369b)

#### Liderança Técnica
- Um time / Vários times
- Desenvolvimento
  - técnico do time
  - pessoas
- "Manter a temperatura da água"
- Gestão do conhecimento

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/3697c06b-ead2-437f-84a6-d4bd0f7570a3)

[https://amzn.to/3scOJj3](https://amzn.to/3scOJj3)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/a0ccc022-94bd-4573-8e3f-f061fcf610c0)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/b14ad7f9-df51-4fa4-9cd6-99d09754eabb)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/ede5fb58-0742-4522-89d0-a384ccb994df)

## Aula 03 - Michael da Costa Móra

### EXTREME PROGRAMMING - XP

#### O surgimento do XP
- Em meados de 1990, Kent Beck buscou formas simples e eficientes para desenvolver software
- Março/1996 - projeto com novos conceitos que resultaram na metodologia *eXtreme Programming(XP)*

#### O que é eXtreme Programming?
- Metodologia ágil, leve
- Desenvolvida para:
  - Equipes pequenas e médias (2 a 12 pessoas)
  - Requisitos vagos e em constante evolução
 
- Baseada nos seguintes valores:
  - Simplicidade
  - Comunicação
  - Coragem
  - Feedback

#### XP x Modelo Tradicional

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/cc5c1114-c95b-42d0-bf71-aab54fc27bde)

### Boas práticas

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/7f0e0b1d-97fc-4a7b-af40-1cc4561bff2b)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/3197f3fb-78b4-4263-b601-0181f009ca68)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/93f6120d-eb12-44b2-9799-635ec405eb73)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/476a78aa-0315-42e3-b3d8-3ea46355a7c0)

#### Papéis no XP

**Big Boss / XpManager**

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/c6834be6-e8ab-4d51-9ded-026cdd26da5d)

**Cliente**

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/37c570f3-3f44-4620-b7f6-d91d6abb1db8)

**Coordenador**

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/a536c018-4529-46a3-93d4-d65819174c24)

**Programador (Driver/Partner)**

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/1c552f89-1d70-452a-93dd-c46abb3b36fa)

**Papéis Combinados**

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/be731a78-38cc-4f76-89b3-08a3e75cf103)

#### Executando XP

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/d730becd-bf41-4be2-9140-b9c0650ba7e3)

### TESTES UNITÁRIO

#### Teste unitário no ciclo de vida de desenvolvimento de software

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/8adc2618-40c2-4ef4-968b-a37674340f98)

#### Entradas para o teste unitário
- Especificação do módulo antes da sua implementação:
  - Fornece subsídios para o desenvolvimento de casos de teste.
  - Fundamental como oráculo.
 
- Código fonte do módulo:
  - Desenvolvimento de casos de teste complementares após a implementação do módulo.
  - Não pode ser usado como oráculo.
 
#### Artefatos gerados pelo teste unitário
- Classes “drivers”
  - São as classes que contêm os casos de teste.
  - Procuram exercitar os métodos da classe “alvo” buscando detectar falhas.
  - Normalmente: uma classe “driver” para cada classe do sistema.
 
- Dublês (“mockups”)
  - Simulam o comportamento de classes necessárias ao funcionamento da classe “alvo” e que ainda não foram desenvolvidas.
  - Quando a classe correspondente ao “dublê” estiver pronta, será necessário re-executar o “driver” que foi executado usando-se o “dublê”.
 
#### Exemplo de criação de classe “driver”

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/7fadec80-9cae-44c7-9b82-68f2b7d75548)

#### Exemplo de conjunto de casos de teste

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/ed86c8be-381b-47ce-b666-f787dd6a5513)

#### Exemplo de classe driver

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/4693d9f8-b49a-42c5-8bec-15d83d8271a6)

#### Vantagens no uso de classes drivers
- Exige que se reflita sobre as funcionalidades da classe e sua implementação antes de seu desenvolvimento.
- Permite a identificação rápida de bugs mais simples.
- Permite garantir que a classe cumpre um conjunto de requisitos mínimos (os garantidos pelos testes).
- Facilita a detecção de efeitos colaterais no caso de manutenção ou refactoring.

#### Dificuldades no uso das classes drivers
- Necessidade de construção do “cenário” em cada método.
- Necessidade de construir um programa para execução dos casos de teste. • Dificuldade em se trabalhar com grandes conjuntos de dados de teste.
- Dificuldade para coletar os resultados.
- Dificuldade para automatizar a execução dos testes.

#### Solucionando as dificuldades
- Uso de ferramentas de automação de teste unitário:
  - JUnit
  - NUnit
  - CppUnit
  - TestNG
  - ...

### XUNIT

[https://xunit.net/](https://xunit.net/)

### JUNIT

[https://junit.org/](https://junit.org/)

### OUTRAS POSSIBILIDADES DO JUNIT

...

### ESTRATÉGIAS DE GERAÇÃO DE CASOS DE TESTE

#### Técnicas de Teste Funcional
- Usam como entrada a especificação do módulo
- Especificação/Contratos:
  - É fundamental gerar casos de teste com valores válidos buscando verificar se o módulo se comporta como especificado.
  - No caso de programação por contratos deve-se gerar casos de teste que busquem verificar se a implementação atende as especificações do contrato.
- Valor Limite
  - Funciona bem quando o programa a ser testado é função de várias variáveis independentes que representam conjuntos que tenham uma relação de ordem.
  - Geração de casos de teste:
    - Fixa-se o valor de todas as variáveis menos uma em seus valores nominais
    - A variável escolhida assume os valores: {MIN,MIN+1,NOMINAL,MAX-1,MAX}
    - Exemplo:
      - v1:int  [10,20]
      - Casos de teste: {10, 11, 15, 19, 20}
  - Se existir mais de uma variável, deve-se testar as combinações possíveis entre ela
  - Se a variável for uma enumeração deve-se testar todos os valores
- Classes de equivalência
  - Princípio: dividir o domínio de entrada em subconjuntos de maneira que o comportamento de um dos membros do conjunto seja representativo do comportamento de todos os membros do conjunto.
  - Gerar pelo menos um caso de teste para cada classe
  - Ex: Nros de telefone (não tem relação de ordem) onde o prefixo indica a operadora.
- Diagramas de estado
  - Se há um diagrama de estados disponível, gerar casos de teste que garantam cobertura de estados e transições.
- Condições de erro
  - Gerar casos de teste que procurem gerar as condições de erro previstas (ex: geração de exceções)
- Valores inválidos
  - Gerar caso de teste com valores de entrada inválidos
- Usa como entrada o código fonte.
- Usado para refinar os casos de teste
  - Gerar o grafo de programa
  - Procurar garantir a cobertura do grafo de programa
    - Verificar se passa por todos os comandos
    - Verificar se exercita cada uma das opções de cada condição
    - Verificar se cada laço itera pelo menos k vezes

### REFATORAÇÃO

#### Refatoração (_Refactoring_)
- Uma [pequena] modificação no sistema que não altera o seu comportamento funcional, mas que melhora alguma qualidade não-funcional:
  - simplicidade
  - flexibilidade
  - clareza
  - desempenho
 
#### Exemplos de Refatoração
- Mudança do nome de variáveis
- Mudanças nas interfaces dos objetos
- Pequenas mudanças arquiteturais
- Encapsular código repetido em um novo método
- Generalização de métodos
  - `raizQuadrada(float x) => raiz(float x, int n)`

#### Aplicações
1. Melhorar código antigo e/ou feito em ciclos de desenvolvimento anteriores.
2. Desenvolvimento incremental (à la XP).
- Em geral, um passo de refatoração é tão simples que parece que ele não vai ajudar muito.
- Mas quando se juntam 50 passos, bem escolhidos, em seqüência, o código melhora radicalmente.

#### Passos de Refatoração
- Cada passo é trivial.
- Demora alguns segundos ou alguns poucos minutos para ser realizado.
- É uma operação sistemática e “óbvia”.
- Ter um bom vocabulário de refatorações e saber aplicá-las criteriosamente e sistematicamente.

#### Refatoração Sempre Existiu
- Mas não tinha um nome.
- Fazia-se de forma ad hoc.
- A novidade está em criar um vocabulário comum e em catalogá-las.
- Viabilizada / estimulada pela prática de testes unitários.

#### Quando Usar Refatoração
- Sempre há duas possibilidades:
  - Melhorar o código existente.
  - Jogar fora e começar do 0.
- Avaliar a situação e decidir quando é a hora de optar por um ou por outro.

#### Origens
- Surgiu (nesta forma) na comunidade de Smalltalk nos anos 80/90.
- Desenvolveu-se formalmente na Universidade de Illinois em Urbana-Champaign.
- Grupo do Prof. Ralph Johnson.
  - Tese de PhD de William Opdyke (1992).
  - John Brant e Don Roberts:
    - _The Refactoring Browser Tool_
- Kent Beck (XP) na indústria.

#### Estado Atual
- Hoje em dia é um dos preceitos básicos do XP.
- Mas não está limitado a XP, qualquer um pode (e deve) usar em qualquer contexto.
- Não é limitado a Smalltalk.
- Pode ser usado em qualquer linguagem
  - Catálogo: orientada a objetos
 
#### Catálogo de Refatorações
- [Fowler, 2000] contém 72 refatorações.
- Análogo aos padrões de desenho orientado a objetos [Gamma et al. 1995] (GoF).
- Vale a pena gastar algumas horas com [Fowler, 2000].

#### Dica #1
Quando você tem que adicionar uma funcionalidade a um programa e o código do programa não está estruturado de uma forma que torne a implementação desta funcionalidade conveniente, primeiro refatore de modo a facilitar a implementação da funcionalidade e, só depois, implemente-a.

#### O Primeiro Passo em Qualquer Refatoração
- Antes de começar a refatoração, verifique se você tem um conjunto sólido de testes para verificar a funcionalidade do código a ser refatorado.
- Refatorações podem adicionar erros.
- Os testes vão ajudá-lo a detectar erros se eles forem criados.

#### Formato de Cada Entrada no Catálogo
- Nome da refatoração.
- Resumo da situação na qual ela é necessária e o que ela faz.
- Motivação para usá-la (e quando não usá-la).
- Mecânica, i.e., descrição passo a passo.
- Exemplos para ilustrar o uso.
