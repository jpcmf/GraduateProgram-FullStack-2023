# Qualidade e Teste de Software

## Aula 01 - Ricardo Beck

> O teste de software é um exercício de disciplina.

### O que é qualidade?

- Qualidade é uma sensação, segundo o QAI, que um produto ou serviço atende a necessidade do cliente.
- Segundo o IEEE, é o grau de conformidade de um sistema, componente ou processo com seus respectivos requisitos.

### O que é um projeto complexo?

São projetos que demandam uma efetiva gestão de riscos no processo tendo como dependências internas e externas. Dependências como diferentes áreas de conhecimento e múltiplas organizações.

### Ciclo de vida de projetos de software

Waterfall - Cascata
- Projetos regulares com etapas definidas para: Investigação, prototipação, desenvolvimento, testes e liberação em produção.

Ciclo de vida ágil
- Projetos interativos onde a cada etapa de tempo (sprint) ocorre uma entrega de valor.

### Tipos de testes e suas características

Para que exista qualidade é necessário que exista repetibilidade no processo e consistência nos fluxos. A segmentação de domínios específicos de teste tenta endereçar camadas direcionadas de qualidade. Qualidade é caracterizada como uma “sensação” pelo Quality Assurance Institute, o usuário ou cliente sabe se um produto tem “qualidade” se esse produto, serviço ou artefato serve ao seu propósito.

### Conceito de caixa transparente

O conceito de “caixa transparente” advém da possibilidade de conhecermos as partes “internas” do artefato a ser testado.

As estratégias que orbitam o domínio da “caixa transparente” aproveitam o conhecimento de como o código foi criado, sua tecnologia e seu acoplamento.

Também são conhecidas expressões como “caixa branca, caixa preta e caixa cinza”.

### Conceito de unidade para teste
- Uma “unidade” pode ser considerada a menor parte indivisível do código.
- Em geral temos:
  - DD path - Caminho decisão à decisão
  - DU path - Declaração e Uso das variáveis
 
### Necessidade de isolamento entre componentes

As unidades devem ser isoladas entre si, de forma a garantir o mínimo de interferência externa quando os estímulos forem recebidos.

Para que sejam criados os níveis de isolamento é necessário se criar Stubs, chamados de esqueletos que sempre respondem a um valor conhecido quando a classe ou método depende de algum agente externo.

Os estímulos gerados devem ser rastreáveis e repetitivos.

### Exemplos de níveis

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/3807de81-eca4-436a-9e6c-9d25559b4e9a)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/7c5363a7-ef4d-4c9e-ad76-d854b41a4d06)

### Estratégias de teste unitário

TDD = Test Driven Development
- Cria-se o teste unitário antes de começar a codificação.
- Nessa estratégia os testes devem sempre falhar inicialmente, após a falha se escreve o código para que o teste passe.

BDD = Behavior Driven Development
- Entende-se a demanda da unidade para que sejam criados os testes. Podem ser baseados em “promessas” ou requisitos funcionais / não-funcionais.

- Como um (pessoa ou perfil)
- Eu gostaria de (funcionalidade)
- Para que (objetivo ou benefício)

Critérios de aceitação:
- Dado que (critério inicial)
- Quando (evento que inicia a ação)
- Então (resultados esperados)

### Diferenças entre teoria e prática

No dia-a-dia cria-se o código e depois testa-se.

Poucos times conseguem ter a disciplina de criar os testes primeiro para verificarem a “falha” para depois implementar o código.

Ferramentas de verificação de código são boas referências para a saúde do código, assim como o entendimento do esforço faltante para complementação de testes.

A regra de ouro é 80% ou mais de cobertura de código.

### Integração dos testes unitários no dia-a-dia

A integração dos testes unitários deve iniciar tão logo o projeto comece, pois muitas vezes o código feito para investigação e pesquisa é mantido para o produto final.

Os sistemas de build devem concentrar a execução dos testes unitários de forma a prover uma execução automática em diferentes níveis.

A cobertura de código deve ser analisada para fins de aprovação ou rejeição do PR (pull- request), no caso de uso de GitHub.

### Ferramental para criação/execução e relatórios

- Java - IDE Eclipse - [JUnit](https://github.com/junit-team/junit5)
- .NET - Visual Studio - [NUnit](https://github.com/nunit/nunit)
- JavaScript - [Mocha](https://github.com/mochajs/mocha)
- [Jest](https://github.com/facebook/jest)
- Criação e apresentação de relatórios: [Allure](https://github.com/allure-framework)

### Processos de Build

Os processos de build devem integrar a capacidade de validar branches progressivamente bem como executar os testes unitários de acordo com o regime requisitado.

Estratégia 1 - executar todos os testes unitários após cada commit. Essa forma provê uma grande confiabilidade no código a ser integrado, porém causa filas no aguardo para validação.

Estratégia 2 - executar os testes relativos ao código a ser inserido na branch principal. Essa estratégia prevê uma maior velocidade e pontualidade dos processos. Todavia, cria- se uma demanda de executar os testes completos ao final de um período de tempo (dia, semana ou sprint).

### Processos de review e merge

Os processos de revisão para o time de desenvolvimento voltado à qualidade devem se ater aos padrões de código definidos pelo time e também a cobertura de testes unitários provida.

Muitas vezes quando postergados os testes unitários acabam por promover novas atividades futuras de retrabalho, conhecidas como dívidas técnicas.

A integração do código gerado com o branch principal só deve ser feita (aprovada) após verificações de padronagem de código, testes unitários e avaliações estáticas de código (como exemplo, [Lint](https://en.wikipedia.org/wiki/Lint_(software)))

### Testes de integração

Os testes de integração avaliam o ecossistema no qual os diferentes métodos ou classes se integram compondo a solução.

As estratégias de teste de integração tendem a exercitar incrementalmente a união parte a parte das unidades.

Exemplo: Em um teste de integração de uma calculadora, seriam feitos testes unitários para cada método (soma, subtração, divisão e multiplicação). A+B, A-B, A/B e A*B

No caso de integração, os testes devem exercitar o conjunto incremental dos métodos soma seguida de subtração e divisão. A+(B-A)*B+B/A

### Estratégias de integração de componentes

Top-down - cria-se testes para a camada mais superior da solução. O grande problema dessa abordagem é a grande quantidade de variáveis para diagnóstico da causa raiz. Mas a complexidade dos testes é mais baixa.

Bottom-up - onde os métodos e classes vão sendo testados aos poucos mantendo partes isoladas. A desvantagem dessa abordagem é o consumo excessivo de tempo para execução e manutenção dos testes a cada interação de software.

Sanduíche - um misto das duas abordagens anteriores, onde partes mais críticas do sistema são testadas individualmente e partes mais estáveis são testadas em alto nível pela integração.

### Ferramental para criação/execução e relatórios

Muitos sistemas de build já incluem opções de integração para auxiliar o processo.

Jenkins - Test Harness

Codeway - Test Pipeline - Usando Jest, JUnit e outros frameworks

### Front-end / Back-end

Enquanto o Back-end é testado através de um conjunto de Rest APIs, e outras estruturas mantidas sem interface com o usuário, o Front-end é exercitado manipulando-se os componentes e controles visuais disponibilizados pela aplicação/solução ou serviço.

### Testes de Interface com o usuário

São os testes realizados manipulando-se os controles disponíveis visualmente.

Principais pontos:
- Verificação do alinhamento dos componentes visuais.
- Verificação dos padrões de ancoragem, padronização das cores, fontes e espaçamentos.
- Verificação do vocabulário usado.

## Aula 02 - Ricardo Beck

## Aula 03 - Daniel Callegari
