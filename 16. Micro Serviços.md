# MicroServiços

## Aula 01 - Vinicius Soares

### SOA (Arquitetura orientada a serviços)

SOA é uma abordagem arquitetural corporativa que permite a criação de serviços de negócio interoperáveis que podem ser facilmente reutilizados e compartilhados entre aplicações e empresas  

#### O que SOA não é?
- Não é uma tecnologia
- Não é um produto
- Não é um WebService
- Não é um software
- Não é um framework
- Não é uma metodologia
- Não é uma solução de negócio

#### Visão Geral
- Uma arquitetura baseada em reusabilidade com serviços bem definidos e providos por componentes de TI;
- Seus componentes possuem baixo acoplamentos;
- Provê plataforma, tecnologia e linguagens independentes;

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/90264ed5-435c-47a9-a245-b0cef58a3d00)

#### Benefícios
- Desacoplamento:
  - Integrações inteligentes, flexibilidade, alinhamento com negócio;

- Reutilização de serviços:
  - Produtividade, manutenibilidade;
 
- Infraestrutura de plataforma:
  - Padronização corporativo (Log, Governança, etc.);
 
![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/cf83275c-727a-401b-9f59-373e6591afd1)
 
### Monolito x Microservices

#### Monolito

Uma arquitetura monolítica típica de um sistema complexo pode ser representada pela figura abaixo, onde todas as funções do negócio estão **IMPLEMENTADAS EM UM UNICO PROCESSO**

#### Vantagens
- Fácil de desenvolver;
- Fácil manutenção;
- Apenas um deploy;
- Tráfego de rede baixo;

#### Problemas
- Aumento de complexidade e tamanho ao longo do tempo;
- Alta dependência de componentes de código;
- Escalabilidade do sistema é limitada;
- Falta de flexibilidade;
- Dificuldade para colocar alterações em produção;

#### O monolito tem vantagens e desvantagens

Uma das grandes desvantagens é que é muito difícil ESCALAR o sistema. Muito comum que cada cliente que você tiver, vai ter que replicar/duplicar o servidor, isso duplicando o custo.

**Quanto mais clientes tiver, mais servidor vai ser preciso, mais caro vai ficar.**

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/abd56df7-4c08-411d-b505-f2ef85da54c4)

#### Microservices

> “um serviço com um único propósito e que execute bem a sua tarefa dentro de um nível de granularidade e suporte as mudanças do sistemas que são consideradas importantes tanto em tempo de projeto quanto em tempo de execução. O foco principal é tentar construir software que pode se adaptar e isto só é possível de ser feito se as partes forem pequenas suficientes para se ajustar às diferenças nas mudanças de sua arquitetura.” –– RUSS MILE

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/4b275019-4986-4444-987b-acbbb7318192)

#### Vantagens
- Manutenção e evolução dos serviços mais estáveis;
- Serviços com baixo nível de acoplamento e interdependência; Escalabilidade do sistema;
- Redução de custos;
- Flexibilidade de tecnologia;
- Facilidade de colocar alterações em produção;
- Resiliencia;
- Aumento da produtividade;
- Implementação de entrega contínua;
- Monitoramento e automação de processos;
- Foco na entrega de valor ao cliente;

#### Riscos
- Aumento da complexidade da coordenação;
- Comunicação entre os microsserviços;
- Governança;

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/8468503a-58fe-4add-80dd-925b209a79cc)

#### Características
- Um conjunto de pequenos autônomos que trabalham juntos. "Newman, Sam";
- Software modularizado em pequenos serviços que se comunicam através de uma forma padronizada;
- Se comunicam através de uma API Restfull (HTTP / Json);

#### Características Técnicas
- Out-of-process:
  - Possibilidade de execução fora dos processos.
 
- Chamadas remotas:
  - Microsserviços são acessados por chamadas remotas.
 
- Independente de linguagem de programação:
  - São agnósticos a linguagem de programação, ou seja, você pode ter serviços escritos em node, java, python, etc.
 
- Baixo acoplamento:
  - Você é dono somente do seu domínio de negócio. Não necessitando de outro serviço para gerar novas versões e ou evoluir seu produto;
 
- Escalabilidade horizontal e vertical:
  - Você pode aumentar o número de réplicas (scale horizontal) e/ou aumentar a capacidade computacional de seu serviço (scale vertical);
 
#### Características Organizacionais
- Agilidade:
  - Trabalhando em conjuntos de negócio menores você garante agilidade no desenvolvimento de software.
 
- Equipe pequena e focada:
  - Utilizando o conceito de two-pizzas team você garante foco e produtividade do time de desenvolvimento.
 
- Entregas rápidas:
  - Por ser altamente testável, um micro serviço pode estar disponível rapidamente em produção com garantias de segurança e qualidade.
 
- Combinação de tecnologias:
  - Times podem ser multidisciplinares em tecnologias para desenvolver os microsserviços.
 
![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/e8bb5f99-7f3c-453b-9fde-8f83b2bf707e)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/014a7b5f-5980-49a1-ac36-c462de0103c3)

#### Práticas recomendadas
- Modele os serviços em torno de domínio da empresa.
- Descentralize tudo. Equipes individuais são responsáveis por projetar e criar serviços. Evite compartilhar esquemas de dados ou códigos.
- O armazenamento de dados deve ser privado para o serviço que é o proprietário dos dados. Use o melhor armazenamento para cada serviço e tipo de dados.
- Os serviços comunicam-se por meio de APIs bem projetadas. Evite o vazamento de detalhes da implementação. As APIs devem modelar o domínio, não a implementação interna do serviço.
- Evite acoplamento entre serviços. Causas de acoplamento incluem protocolos de comunicação rígidos e esquemas de banco de dados compartilhados.
- Descarregue preocupações abrangentes, como autenticação e terminação SSL, para o gateway.
- Mantenha o conhecimento de domínio fora do gateway.
- Os serviços devem ter um acoplamento flexível e alta coesão funcional.
- Isole falhas. Use estratégias de resiliência para impedir que falhas em um serviço distribuam-se em cascata.

#### Capabilities

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/4524999e-925b-4970-a4cc-931a19f96d22)

#### Falácias
- A rede é confiável;
- Latência é zero;
- A banda de internet é infinita;
- A rede é segura;
- A topologia de rede não muda; Existe somente UM administrador; Custo de transporte é zero;
- A rede é homogênea;

### IaaS (Infraestrutura como Serviço)

#### Características
- Infrastructure as a Service significa entregar computação de infraestrutura sob demanda.
- É um dos 3 modelos de serviços da computação em nuvem.
- IaaS provê:
  - Servidores: Computação e máquinas;
  - Storage;
  - Rede;
  - Sistemas Operacionais;
- O usuário ao invés de adquirir softwares ou máquinas, espaço em data centers ou equipamentos de rede ele praticamente aluga espaços para estes recursos em uma infraestrutura externa.
- IaaS pode ser obtida em:
  - Nuvem pública:
    - É considerada nuvem pública uma infraestrutura que consiste de recursos compartilhados, liberados sob demanda baseado na internet.
  - Nuvem privada:
    - Incorpora a maioria das features de uma nuvem pública como virtualização porém fica dentro de uma rede privada.
  - Nuvem Híbrida:
    - Mistura de uma nuvem privada com uma nuvem pública, geralmente conectadas através de um túnel VPN.   
- Recursos são distribuídos como serviço;
- Possibilita escalabilidade dinâmica;
- Custos variados;

#### Quando utilizar
- Quando a demanda for volátil, ou seja, você tem a possibilidade diminuir e aumentar sua capacidade computacional de acordo com a necessidade.
- Empresas sem capacidade de investimento em hardware.
- Empresas com crescimento rápido e necessidade de escala rápida de sua infraestrutura.
- Por estratégias de negócios rápidas.

#### Quando não utilizar
- Quando a legislação não permitir guardar os dados fora da infraestrutura interna da empresa, ou a terceirização do armazenamento não é permitida.
- Não é aconselhável quando os níveis de desempenho necessários para aplicação tenham limite de acesso ao provedor da cloud.

### PaaS (Plataforma como Serviço)

#### Características
- PaaS pode ser considerada IaaS adicionada uma camada middleware e/ou componentes prontos.
- Uma camada de abstração entre seu aplicativo em nuvem e seu provedor de IaaS.
- É um ambiente de execução escalável e com alta disponibilidade para aplicações customizadas.
- PaaS, é uma categoria de computação em nuvem que fornece uma plataforma e um ambiente para permitir que os desenvolvedores criem aplicativos e serviços pela Internet.
- Fornece fundamentalmente escala elástica do seu aplicativo.

#### Benefícios
- Infraestrutura na nuvem, escalável e com alta disponibilidade nativa.
- Alta produtividade no desenvolvimento e manutenção de aplicações sob demanda.
- Resumindo: baixo custo (TCO), confiabilidade e diminuição do tempo de entrega.

#### Vantagens
- Desenvolvimento 100% focado no negócio:
  - Por direcionar a arquitetura lógica e administrar a arquitetura física de forma bem transparente, é possível desenvolver uma aplicação que vá demandar uma requisição por minuto ou 10 mil requisições por segundo da mesma forma, com o mesmo nível de preocupação do ponto de vista técnico: apenas a lógica de negócio.
 
- Produtividade
  - O simples fato de não se gerenciar balanceamento de carga, replicação,cluster, instalando e configurando middlewares(servidores de aplicação, banco de dados, etc.) já é um grande ganho. Além disso, os grandes fornecedores estão criando camadas de componentes prontos para uso, APIs e aceleradores de desenvolvimento nessas plataformas.
 
#### Decisões
- A plataforma por trás do PaaS foi criada justamente para trazer benefícios e acelerar o desenvolvimento. Existe esforço dos fornecedores para deixar essa camada o mais padrão possível, mas ainda existe uma boa parte que é proprietária.
- Ao adotar PaaS, é natural que se adote também essa camada proprietária, caso contrário, poderia se trabalhar direto na infraestrutura.
- É esta camada que permite dar um salto de produtividade e lidar com escalabilidade e disponibilidade de forma transparente.
- A decisão a ser tomada é: menos custo e mais entregas contra o efeito “lock-in” das aplicações construídas nessa abordagem.!

#### Restrições
- Plataformas são muito eficientes para construção de novas aplicações.
- A migração de aplicações já existentes para elas é um processo custoso ou mesmo inviável (dependendo da tecnologia atual e da plataforma almejada).

### THE TWELVE Factor for App

#### 1 - Base de Código
- Somente uma base de código por aplicação;
- Vários deploys por aplicação;
- Desenvolvedor possui uma cópia local do repositório;

#### 2 - Dependências
- Declare e isole explicitamente as dependências;
- Uma aplicação 12 fatores nunca confia na existência implícita de pacotes em todo o sistema;
- Uma declaração de dependência explícita é que simplifica a configuração da aplicação para novos desenvolvedores;
- Na prática:
  - Tenha sempre um gerenciador de dependências configurado para seu projeto (maven, gradle, npm, pip e etc);
 
#### 3 - Configurações
- A configuração de uma aplicação é tudo que é provável variar entre deploys(homologação, produção, desenvolvimento, etc).
- Uma aplicação 12 fatores armazena configuração em variáveis de ambiente ou algum recurso de configuração distribuída.
- Necessitamos de facilidade na troca de ambientes sem ter a necessidade de alterar o codebase.

#### 4 - Serviços de Apoio
- Trate serviços de apoio como recursos anexados;
- Serviço de apoio é qualquer serviço que o App consuma via rede como parte de sua operação normal:
  - Ex: Banco de Dados, Mensageria, Cache.
- Não se deve fazer distinção entre serviços locais e terceiros;

#### 5 - Construa, lance, execute
- Uma base de código é transformada em um deploy através de 3 estágios:
  - Construção: Converte o repositório em um pacote executável;
  - Lançamento: Combina o artefato construído com a configuração do deploy.
  - Execução: Roda o app no ambiente de execução através dos processos específicos do APP.
- O app 12 fatores utiliza separação estrita entre os estágios de construção, lançamento e execução.

#### 6 - Processos
- Você não deve introduzir estado em seus serviços; os aplicativos devem ser executados como um processo único e sem estado.
- Os processos dos Doze Fatores são stateless e não compartilham nada. Esse fator está no núcleo da arquitetura de microsserviços.

#### 7 - Vínculo de porta
- Seu serviço deve estar visível para outras pessoas via ligação de alguma porta. Se você criou um serviço, verifique se outros serviços podem tratar isso como um recurso, se assim o desejarem. O aplicativo de doze fatores é completamente independente de outros recursos.

#### 8 - Concorrência
- Divida seu aplicativo em pequenos pedaços, em vez de tentar aumentar seu aplicativo (executando uma única instância na máquina mais poderosa disponível). Aplicativos pequenos e definidos permitem a expansão conforme necessário para lidar com as cargas variadas. O processo deve ser dimensionado individualmente, com o Fator 6 (sem estado), torna-se transparente este tipo de abordagem.

#### 9 - Descartabilidade
- Os processos devem consumir menos tempo. Certifique-se de poder correr e parar rapidamente. E que você pode lidar com falhas. Sem isso, o dimensionamento automático e a facilidade de implantação e desenvolvimento estão sendo diminuídos. Você pode conseguir isso com contêineres.

#### 10 - Paridade entre desenvolvimento e produção
- Mantenha o desenvolvimento, a homologação e a produção o mais semelhante possível, para que qualquer pessoa possa utilizá-lo da mesma forma. A implantação contínua precisa de integração contínua com base em ambientes correspondentes para limitar desvios e erros. Isso também incentiva implicitamente uma cultura DevOps na qual o Desenvolvimento e as Operações de Software são unificados.

__A conteinerização é uma grande ajuda aqui.__

#### 11 - Logs
- Trate os logs como fluxos de eventos. O registro é importante para validar erros e também verificar a integridade geral do seu sistema. Ao mesmo tempo, seu aplicativo não deve se preocupar com o armazenamento dessas informações. Esses logs devem ser tratados como um fluxo contínuo capturado e armazenado por um serviço separado.

#### 12 - Processos Administrativos
- Execute tarefas administrativas / gerenciamento como processos pontuais - tarefas como migração de banco de dados ou execução de scripts pontuais no ambiente. Para evitar mexer com o banco de dados, use as ferramentas criadas ao lado do aplicativo e isole completamente sua aplicação por exemplo.

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/f654761b-7195-4e53-bb19-f59ff5986172)

### APLICAÇÕES Cloud Native

#### Definição - CNCF
- Containerizado;
- Gerenciado dinamicamente;
- Orientado a microserviços:
  - Automação;
  - Registro e Descoberta;
  - Rastreamento distribuído / Observabilidade;
- Cloud:
  - Elasticidade;
  - Modelo on-demand;

#### Definição - Pivotal
- Devops:
  - Processos;
  - Ferramentas;
  - Cultura;
- Entrega contínua:
  - Automação;
- Microsserviços:
  - Automação;
  - Registro e Descoberta;
  - Rastreamento distribuído / Observabilidade;
  - Anti-fragilidade / Engenharia de caos;
- BOSH:
  - Suporte a múltiplas clouds (evitar ficar preso a um provider);
  - Separação clara entre sistemas;
  - Provisionamento rápido;
  - Escalabilidade;
  - Monitoramento de saúde;
  - Controle de falhas;
  - Deploy canário;
 
![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/c8614dde-8074-4507-9c8a-6774f0bc3fb1)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/45b940ef-2a81-429f-89b5-f8f34c719401)

#### Características
- Arquiteturas cloud native aprimoram nossa capacidade de praticar DevOps e Entrega Contínua (Continuous Delivery), e elas exploram as características da infraestrutura na nuvem (Cloud Infrastructure).
- "Cloud-native" é um adjetivo que descreve as aplicações, arquiteturas, plataformas / infraestrutura, e processos que, em conjunto, tornam "econômico" trabalhar de forma a melhorar nossa capacidade de responder rapidamente às mudanças e reduzir a imprevisibilidade.
- Arquiteturas cloud-native aprimoram nossa capacidade de praticar DevOps e Continuous Delivery, e elas exploram as características da infraestrutura na nuvem. Eu defino arquiteturas cloud-native como tendo as seguintes seis qualidades:
  - Modularidade (através de Microservices);
  - Capacidade de observação;
  - Implementabilidade;
  - Testabilidade;
  - Descartabilidade;
  - Substituível;
- Criado para ser escalável;
- Tolerante a falhas;
- Decomposto em serviços;
- Envia o máximo trabalho para a plataforma se possível;
- Automatizado;

### CONTAINERS

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/02a73729-666c-48fb-89ef-75bd623b1667)

#### Características
- Pequenos sistemas Linux minimalistas;
- Compartilhado Kernel do Host;
- Processos trabalhando isoladamente;
- Commits e versionamento de containers;
- Compartilhamento de ambientes customizados;
- Por que os contêineres são bons para micro serviços?
  - Projetado para executar um aplicativo por contêiner;
  - Separação natural da carga de trabalho;
  - Muito leve;
  - Ótimo para dimensionar rapidamente;
  - Melhor uso de recursos;
  - Os contêineres compartilham o SO host e, quando apropriado, Binários e bibliotecas;
- Formatos padrão de contêiner, como o Docker, são distribuições cruzadas entre linux compatível;
- Incrivelmente fácil de mover sua carga de trabalho • Equilibre melhor os recursos do sistema;
- Permita que os desenvolvedores trabalhem em um ambiente de produção simulado;
- Remove o problema "funcionou na minha máquina";

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/6053ab8a-c90a-4684-ada2-0f5a041228a1)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/0f5f8f0c-4d0b-44b2-8e4b-ea9363feffd2)

#### Docker

Tecnologia Open Source que permite criar, executar, testar e implantar aplicações distribuídas dentro de containers de software. Ele permite que você empacote um software de uma padronizada para o desenvolvimento de software, contendo tudo que é necessário para a execução: código, runtime, ferramentas, bibliotecas, etc. Docker permite que você implante aplicações rapidamente, de modo confiável e estável, em qualquer ambiente.

- Existem mais de 500 mil aplicações Dockerizadas, um crescimento de 3100% ao longo de 2 anos;
- Mais de 4 bilhões de containers já foram puxados até hoje;
- Docker é apoiado por uma grande e crescente comunidade de colaboradores e usuários;
- A adoção do Docker aumentou mais de 30% no último ano;
- Cerca de 30% dos containers Dockers estão rodando em produção. \29% das empresas que já ouviram falar em Docker planejam usá-lo;

A parte cliente fala com o Docker daemon, que faz o trabalho pesado de construção, execução e distribuição de seus containers e imagens Docker, também controla os recursos executados. O cliente Docker e Docker daemon, podem ser executados no mesmo sistema, também é possível conectar um cliente Docker a um Docker daemon remoto. O cliente Docker e daemon se comunicam através de uma API REST, através de sockets UNIX ou uma interface de rede, para execuções de comandos ou scripts.

#### Container
- Containers tem como base sempre uma imagem, pense como na seguinte analogia do mundo Java, uma imagem é uma classe e um container é como um objeto instância dessa classe, então podemos através de uma imagem “instanciar” vários containers, também através de recursos chroot, Cgroups é possível definirmos limitações de recursos recursos e isolamento parcial ou total dos mesmos.
- Algumas características dos containers
  - Portabilidade de aplicação;
  - Isolamento de processos;
  - Prevenção de violação externa;
  - Gerenciamento de consumo de recursos;

#### Imagem

Imagens são templates para criação de containers, como falado no slide anterior, imagens são imutáveis, para executá-las é necessário criar uma instância dela (container), também vale ressaltar que as imagens são construídas em camadas, o que facilita sua reutilização e manutenção. Em resumo uma imagem nada mais é do que um ambiente totalmente encapsulado e pronto para ser replicado onde desejar.

#### Dockerfile

São scripts com uma série de comandos para criação de uma imagem, nesses scripts podemos fazer uma séries de coisas como executar comandos sh, criar variáveis de ambiente, copiar arquivos e pastas do host para dentro da imagem.

#### Docker Registry

É como um repositório GIT, onde as imagens podem ser versionadas, comitadas, “puxadas” etc, quando recuperamos uma imagem, usando o comando docker pull por exemplo, estamos normalmente baixando a imagem de um registro Docker, o repositório oficial do Docker é o Docker HUB, onde é possível hospedar e versionar imagens públicas e privadas.

#### Arquitetura Básica

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/b3d63649-44dd-467a-bffc-4a53e758024d)

## Aula 02 - Vinicius Soares

### PARTICIONAMENTO DE SERVIÇOS

#### Domain Drive Design
- Fundamentado na experiência de mais de 20 anos de Eric Evans no desenvolvimento de sistemas, o DDD é uma abordagem que reúne um conjunto de boas práticas, padrões, ferramentas e recursos da orientação a objetos que têm como objetivo a construção e desenvolvimento de sistemas de acordo com o domínio e regras de negócio do cliente.
- Além disso, questões relacionadas ao processo de desenvolvimento, como a necessidade de um estreito relacionamento entre a equipe de programadores e os especialistas do domínio, também são tratadas pela abordagem.
- O principal conceito do DDD é o modelo.
- O modelo expressa o domínio e negócio do cliente e pode ser criado utilizando desenhos, fluxogramas, diagramas, etc.
- O importante é que ele represente o negócio do cliente.
- Como principais componentes do DDD, podemos listar: a linguagem onipresente, a arquitetura em camadas e os padrões.
- É uma abordagem de desenvolvimento de software que reúne um conjunto de conceitos, princípios e técnicas cujo foco está no domínio e na lógica do domínio com o objetivo de criar um Domain Model ou (modelo do domínio).
- Significa desenvolver software de acordo com o domínio relacionado ao problema que estamos propondo resolver.
- O foco da abordagem é criar um domínio que “fale a língua” do usuário usando o que é conhecido como linguagem Ubíqua(ubiquitous language ou linguagem Comum,Onipresente)
- Linguagem Ubíqua (linguagem comum) entende-se que ao trabalhar com DDD devemos conversar usando uma mesma língua, em um único modelo, de forma que o mesmo seja compreendido pelo cliente, analista, projetista, desenhista, testador, gerente, etc. nesta linguagem, que seria a linguagem usada no dia a dia.

#### Domain Drive Design - Camadas

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/994b3457-284c-4a63-b14e-6a008e2007ea)

#### Domain Drive Design - Modelo
- O modelo é evolutivo: A cada iteração entre especialistas de domínio e a equipe técnica, o modelo se torna mais profundo e expressivo, mais rico, e os desenvolvedores transferem essa fonte de valor para o software.
- Assim, o modelo vai sendo gradualmente enriquecido com o expertise dos especialistas do domínio destilado pelos desenvolvedores, fazendo com que o time ganhe cada vez mais insight sobre o negócio e que esse conhecimento seja transferido para o modelo (para o código) através dos blocos de construção do DDD.
- Quando novas regras de negócio são adicionadas e/ou regras existentes são alteradas ou removidas, a implementação é refatorada para refletir essas alterações do modelo no código.
- No final, o modelo (que em última instância será o software) vai expressar com riqueza de conhecimento o negócio.

#### Modelo DDD com arquitetura Hexagonal e Layered

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/21875d66-df44-4390-9397-27daea06af1e)

#### Vantagens
- O código fica menos acoplado e mais coeso.
- O negócio é melhor compreendido por todos da equipe o que facilita o desenvolvimento.
- Alinhamento do código com o negócio.
- Favorecer reutilização.
- Mínimo de acoplamento.
- Independência da Tecnologia.

#### DDD e Event Storming
- Event Storming é uma técnica de design rápido que engaja especialistas do domínio de negócios com desenvolvedores para que alcancem um ciclo rápido de aprendizagem (aprender o máximo possível no menor tempo possível
- Segundo Martin Flowler - Bounded Context (Contexto limitado) é um padrão central no design orientado a domínio.
- É o foco da seção de design estratégico da DDD que trata de lidar com grandes modelos e equipes. O DDD lida com modelos grandes, dividindo-os em diferentes contextos limitados e sendo explícito sobre suas inter-relações.
- Para encontrar os comandos, agregações e boundaries usaremos o conceito de Evento Storming;
- Event Storming é uma técnica de design rápido que engaja especialistas do domínio de negócios com desenvolvedores para que alcancem um ciclo rápido de aprendizagem (aprender o máximo possível no menor tempo possível;

### EVENTOS DE DOMÍNIOS

#### Eventos de domínios
- Use eventos de domínio para implementar explicitamente os efeitos colaterais de alterações em seu domínio. Em outras palavras, e usando terminologia DDD, use eventos de domínio para implementar explicitamente efeitos colaterais entre várias agregações.
- Opcionalmente, para melhor escalabilidade e menor impacto em bloqueios de banco de dados, use consistência eventual entre agregações dentro do mesmo domínio.
- Um evento é algo que ocorreu no passado. Um evento de domínio é algo que ocorreu no domínio que você deseja que outras partes do mesmo domínio (em processo) tenham conhecimento. As partes notificadas geralmente reagem de alguma forma aos eventos.
- Um benefício importante dos eventos de domínio é que os efeitos colaterais podem ser expressos explicitamente.
- Em resumo, eventos de domínio ajudam você a expressar, explicitamente, as regras de domínio, com base na linguagem ubíqua fornecida pelos especialistas do domínio. Os eventos de domínio também permitem uma melhor separação de interesses entre classes dentro do mesmo domínio.
- É importante garantir que, assim como uma transação de banco de dados, todas as operações relacionadas a um evento de domínio sejam concluídas com êxito ou nenhuma delas seja.
- Os eventos de domínio são parecidos com eventos do estilo de mensagens, com uma diferença importante. Com mensagens reais, enfileiramento de mensagens, agentes de mensagens ou um barramento de serviço que usa o AMQP, uma mensagem é sempre enviada de forma assíncrona e comunicação entre processos e computadores.
- Isso é útil para a integração de vários contextos delimitados, microsserviços ou até mesmo aplicativos diferentes. No entanto, com os eventos de domínio, ao acionar um evento na operação de domínio em execução no momento, você deseja que os efeitos colaterais ocorram dentro do mesmo domínio.
- A primeira etapa do Event Storming consiste em mapear os eventos que ocorrem no domínio que está sendo estudado.
- Um evento é qualquer coisa relevante que aconteceu no passado e tende a ser de simples compreensão para pessoas não técnicas.
- O padrão para descrever o evento é utilizar o verbo no passado e deve-se tentar mapear todos os eventos.
- Para essa etapa, utilizamos os post-its de cor laranja.
- Talvez possa existir um pouco de dificuldade inicial para explicar o que é um evento para os especialistas de negócios (não técnicos).
- O facilitador deve cuidar para que, sem que percebam, os participantes fujam do escopo da etapa e comecem a citar o mapeamento das entidades ou regras de negócios.
- Alguns exemplos de eventos identificados: Produto Ativado, Produto Desativado, Licença Utilizada, Licença Liberada, Novo Ambiente Criado.

### COMANDOS

#### Comandos de domínio
- Nesta etapa, você muda da análise do domínio para os primeiros estágios do design do sistema.
- Até esse momento, você está simplesmente tentando entender como os eventos no domínio se relacionam - é por isso que a participação de especialistas em domínios é tão crítica.
- No entanto, para criar um sistema que implemente o processo de negócios em que você está interessado, é necessário passar à questão de como esses eventos ocorrem.
- Os comandos são o mecanismo mais comum pelo qual os eventos são criados.
- A chave para encontrar comandos é fazer a pergunta: "Por que esse evento ocorreu?".
- Nesta etapa, o foco do processo passa para a sequência de ações que levam a eventos;
- Seu objetivo é encontrar as causas pelas quais os eventos registram os efeitos. Os tipos de gatilhos de eventos esperados são:
  - Um operador humano toma uma decisão e emite um comando;
  - Algum sistema ou sensor externo fornece um estímulo (SEDA, EDA, Cron, Event Sourcing);
  - Um evento resulta de alguma política - processamento tipicamente automatizado de um evento precursor;
  - A conclusão de algum período determinado de tempo decorrido;
- Outra parte importante do processo que se torna mais detalhada nessa etapa é a descrição de políticas que podem acionar a geração de um evento a partir de um evento anterior (ou conjunto de eventos).
- Avalie se o elemento de dados é uma entidade comercial principal, identificada exclusivamente por uma chave, suportada por vários comandos.
- Tem uma vida útil ao longo do processo de negócios. Isso levará ao desenvolvimento de uma análise do ciclo de vida da entidade.
- Esse primeiro nível de definição de dados ajuda a avaliar o escopo e a responsabilidade do micro serviço à medida que você começa a ver pontos em comum emergindo dos dados usados entre vários eventos relacionados.
- O comando de disparo é identificado em um post-it azul.
- O comando pode se tornar uma operação de micro serviço exposta via API.
- A pessoa humana que emite o comando é identificada e mostrada em uma nota laranja.
- Alguns eventos podem ser criados aplicando políticas de negócios.
- Identificação dos comandos que geram os eventos;
- Geralmente os comandos estão associados à alguma ação do usuário, interação com sistema externo ou gerados por um temporizador/cron;
- Verbo na forma imperativa;
- Deve ser colocado no lado esquerdo do evento que ele gera;
- Durante o processo, é comum identificar que um comando pode gerar vários eventos;

### AGREGAÇÕES

#### Agregação
- Agregação é um padrão no Domain Driven Design.
- Um agregado DDD é um cluster de objetos de domínio que podem ser tratados como uma única unidade.
- Um exemplo pode ser um pedido e seus itens de linha, esses serão objetos separados, mas é útil tratar o pedido (junto com seus itens de linha) como um único agregado.
- Um agregado terá um de seus objetos componentes como a raiz agregada. Quaisquer referências externas ao agregado devem apenas ir para a raiz agregada.
- A raiz pode assim garantir a integridade do agregado como um todo.
- Agregados são o elemento básico da transferência de armazenamento de dados - você solicita carregar ou salvar agregados inteiros. As transações não devem cruzar fronteiras agregadas.
- Às vezes, os agregados DDD são confundidos com as classes de coleção (listas, mapas, etc.). Agregados DDD são conceitos de domínio (ordem, visita à clínica, lista de reprodução), enquanto as coleções são genéricas.
- Um agregado geralmente contém coleções múltiplas, junto com campos simples.
- O termo "agregado" é comum e é usado em vários contextos diferentes (por exemplo, UML), caso em que não se refere ao mesmo conceito que um agregado DDD.
- Os aggregates são a parte do sistema que recebem os comandos e que geram os eventos, eles são os objetos que armazenam os dados e são modificados pelos comandos.
- Aplicativos tradicionais têm usado frequentemente transações de banco de dados para impor a consistência.
- Em um aplicativo distribuído, no entanto, isso muitas vezes não é viável.
- Uma única transação empresarial pode abranger vários repositórios de dados, ser demorada ou envolver serviços de terceiros.
- Por fim, cabe ao aplicativo, não à camada de dados, impor as variáveis necessárias para o domínio. É isso que as agregações destinam-se a modelar.
- São a parte do sistema que recebem os comandos e que geram os eventos, eles são os objetos que armazenam os dados e são modificados pelos comandos.
- Pode-se utilizar o nome entidade ou dado quando falar sobre Aggregate.
- Durante o exercício, pode ser que os Aggregates se repitam ao longo da linha do tempo, mas não se deve agrupá-los.

### LIMITES

#### Limites
- Bounded Context é um padrão central no design orientado a domínio.
- É o foco da seção de design estratégico da DDD que trata de lidar com grandes modelos e equipes.
- O DDD lida com modelos grandes, dividindo-os em diferentes contextos limitados e sendo explícito sobre suas inter-relações.
- À medida que você tenta modelar um domínio maior, fica progressivamente mais difícil criar um único modelo unificado.
- Diferentes grupos de pessoas usarão vocabulários sutilmente diferentes em diferentes partes de uma grande organização.
- A precisão da modelagem rapidamente se depara com isso, muitas vezes levando a muita confusão. Normalmente, essa confusão se concentra nos conceitos centrais do domínio.
- Contextos limitados têm conceitos não relacionados (como um tíquete de suporte existente apenas em um contexto de suporte ao cliente), mas também compartilham conceitos (como produtos e clientes).
- Contextos diferentes podem ter modelos completamente diferentes de conceitos comuns, com mecanismos para mapear entre esses conceitos polissêmicos para integração.

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/d6982228-ccb9-4ecf-8bc4-8c68091be51f)

- Vários fatores traçam limites entre contextos.
- Normalmente, a dominante é a cultura humana, já que os modelos agem como linguagem onipresente, você precisa de um modelo diferente quando a linguagem muda.
- Você também encontra vários contextos no mesmo contexto de domínio, como a separação entre os modelos de banco de dados relacional e na memória em um único aplicativo.
- Esse limite é definido pela maneira diferente como representamos os modelos.

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/0c7f21ee-541a-42e8-a144-dd0c12c8d40a)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/4f63587f-6311-460f-8daa-7851eeeb8e30)

![image](https://github.com/jpcmf/GraduateProgram-FullStack-2023/assets/1216136/4fefe693-4cc1-4814-a6e8-ba88e673de8e)

- Podem estar relacionados à divisões departamentais.
- Podem ser diferentes visões que os especialistas do negócio possuem sobre o mesmo conceito.
- Agregadores que são importantes.
- Mapear eventos que “naveguem” entre os domínios.

## Aula 03 - Luis Fernando Planella Gonzalez 
